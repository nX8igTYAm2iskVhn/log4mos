# Log4Mos

A logging gem for MOS applications. This is aimed to replace other approaches that rely on ``ActiveSupport::Notifications``

It works both as framework for defining logging outputing based on event types (with support for payload filtering and outputing to multiple desitnations) and as registry for different loggers

Here are the main concepts behind this gem:

## Filters

A filter is a way to process a logging payload as needed. This can include replacing sensitive information from the payload (emails, bank accounts, etc) or extending it with scoped information (request id, current logged user, current deploy sha, etc)

You can take a look at the following files for example of filters:
- [Request context filter](lib/log4mos/filters/request_context.rb)
- [Database Runtime filter](lib/log4mos/rails/database_runtime_filter.rb) (depends on ActiveRecord)
- [Parameters Filtering filter](lib/log4mos/filters/parameters_filter.rb)

If you need to write your own filter for appending data to payloads, use the [Log4Mos::Filters::PayloadFilter module](lib/log4mos/filters/payload_filter.rb).

## Sinks

Sinks are desitinations to which the logged information must be written to: plain log file, splunk log file, Airbrake, etc.
Currently, we have out of the box support for the following:
- [Splunk](lib/log4mos/sinks/splunk.rb) with [JSON formatting](lib/log4mos/sinks/json_formatter.rb) or [CSV like formatting](lib/log4mos/sinks/csv_formatter.rb) (please use JSON for new projects)
- [Airbrake](lib/log4mos/sinks/airbrake.rb) for sending error information to, well, Airbrake
- Plain [RubyLogger](lib/log4mos/sinks/ruby_logger.rb), but this should be used for testing purposes only

## Registry

You can use Log4Mos as a registry of different loggers you create. This can be helpful for integrating with applications with other gems that also use Log4Mos. But in most cases, you will probably only need to use the default logger.

```ruby
require 'log4mos'

default_logger = Log4Mos::Logger.new
... initialize logger ...
Log4Mos::register(default_logger)

Log4Mos.logger.info 'event', {some_payload}
assert_true Log4Mos.logger == Log4Mos.logger(:default)
```

The `Log4Mos#register` also accepts a parameter for the name of the logger:
```ruby
require 'log4mos'

special = Log4Mos::Logger.new
... initialize logger ...
Log4Mos::register(:special, special)

Log4Mos.logger(:special).info 'wow', {special_payload}
```


## Usage

### Rails

If you're working on a Rails app, using Log4Mos couldn't be more simple:

```ruby
# in config/initializers/log4mos.rb
require 'log4mos/rails'
```

And that's it!
This should enable most of what you need. Here's what's provided:
- Creates a default logger that can be accessed from `Log4Mos.logger`
- Enables splunk logging into the #{Rails.root}/log/splunk.log file, using the INFO level and JSON formatting
- Enables Airbrake integration for events with exception data on the ERROR level
- Adds database runtime information from ActiveRecord to each logged event
- Includes information from the current RequestContext object ([see the request_context gem](https://github.nX8igTYAm2iskVhndev.com/nX8igTYAm2iskVhn/request_context))
- Adds parameter filtering to payloads based on Rails `config.filter_parameters`
- Subscribes to and logs `'process_action.action_controller'` events

Take a look at the [rails file](/lib/log4mos/rails.rb) for more detail on how this is being done.

### Not Rails

If you're not using rails on your application, the above approach won't really work, so you'll have to setup things yourself. But this should still be pretty easy, although not as magical:

```ruby
require 'log4mos'
require 'log4mos/sinks/splunk'

ruby_logger = ::Logger.new('/path/to/splunk.log')
ruby_logger.level = ::Logger::INFO

logger = Log4Mos::Logger.new
# Creates a splunk sink with JSON format. Use Log4Mos::Sinks::Splunk.new(ruby_logger, formatter_class) for a different one
logger.sinks << Log4Mos::Sinks::Splunk.new(ruby_logger)
fail "Please don't just copy and paste this, take a look at the code and use what you need"

# Uncomment this if you have Airbrake integration
#require 'log4mos/sinks/airbrake'
#logger.sinks << Log4Mos::Sinks::Airbrake.new

Log4Mos.register(logger)

```

### ActiveSupport::Notifications integration

Even though we shouldn't be using `ActiveSupport::Notifications` for application logging, we may still want to
log events produced by it (Rails or other third-party libs events).

Let's say we want to log 'sql.active_record' events generated by ActiveRecord. We can accomplish that by writing:
```ruby
Log4Mos::Notifications.subscribe_to(:sql, :active_record)
```

The above code will log events using the default registered logger (`Log4Mos.logger`) with INFO level.
You can override this by passing which logger and level to use:
```ruby
Log4Mos::Notifications.subscribe_to(:sql, :active_record, logger: Log4Mos.logger(:sql_logger), level: :debug)
```

## Log Filters

Implementing your own filters should be really simple. Here are a few examples:

```ruby
# You can use filters to execute around logged block executions
class ActiveRecordDbDurationLogFilter
  def call(filter_chain, level, event_name)
    db_runtime_start = ActiveRecord::LogSubscriber.runtime
    return_value, editable_payload = filter_chain.next
    editable_payload[:db_runtime] = ActiveRecord::LogSubscriber.runtime - db_runtime_start

    return_value, editable_payload
  end
end

# Or use them for filtering/augmenting log data
class RemoveSenstiveDataLogFilter
  include Log4Mos::Filters::PayloadFilter

  def filter(editable_payload, level, event_name)
    editable_payload[:card_number] = '[FILTERED]' if editable_payload[:card_number]

    editable_payload
  end
end

class RequestInfoLogFilter
  include Log4Mos::Filters::PayloadFilter

  def filter(editable_payload, _, _)
    editable_payload[:request_id] = RequestInfo.request_id
    editable_payload[:current_user] = RequestInfo.current_user

    editable_payload
  end
end

Log4Mos.logger.filters << ActiveRecordDbDurationLogFilter.new
Log4Mos.logger.filters << RequestInfoLogFilter.new
# It's possible to scope filters by event name
Log4Mos.logger.filters_for_event(:transaction) << RemoveSenstiveDataLogFilter.new
```

The `Log4Mos::Filters::PayloadFilter` module makes it easier to define filters that only needs to append or change data from payload.


## Log Sinks

And here are a few examples of how you can implement you're own sink types:

```ruby
class StdoutSink
  def call(level, payload)
    Stdout.puts(payload.inspect)
  end
end

class AirBreakSink
  def call(level, payload)
    Airbrake.notify(payload[:exception]) if level == :error && payload[:exception]
  end
end

Log4Mos.logger.sinks << StdoutSink.new
Log4Mos.logger.sinks << AirBreakSink.new

```
